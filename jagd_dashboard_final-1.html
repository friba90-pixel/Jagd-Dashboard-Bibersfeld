<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schwarzwild Dashboard v3.3</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0d1117;
            --bg-card: #161b22;
            --bg-card-hover: #1c2333;
            --bg-input: #0d1117;
            --border: #30363d;
            --border-light: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --green: #3fb950;
            --green-dim: rgba(63,185,80,0.15);
            --green-glow: rgba(63,185,80,0.4);
            --red: #f85149;
            --red-dim: rgba(248,81,73,0.15);
            --yellow: #d29922;
            --yellow-dim: rgba(210,153,34,0.15);
            --orange: #db6d28;
            --blue: #58a6ff;
            --accent: #3fb950;
            --font-mono: 'JetBrains Mono', monospace;
            --font-sans: 'DM Sans', -apple-system, sans-serif;
            --radius: 12px;
            --radius-sm: 8px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font-sans);
            background: var(--bg-deep);
            color: var(--text-primary);
            padding: 20px;
            min-height: 100vh;
            line-height: 1.5;
        }

        .container { max-width: 1800px; margin: 0 auto; }

        /* ===== HEADER ===== */
        .header {
            background: linear-gradient(135deg, #1a2e1a 0%, #162016 50%, #0d1117 100%);
            padding: 28px 32px;
            border-radius: var(--radius);
            margin-bottom: 24px;
            border: 1px solid rgba(63,185,80,0.2);
            position: relative;
            overflow: hidden;
        }
        .header::before {
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 300px; height: 100%;
            background: radial-gradient(ellipse at top right, rgba(63,185,80,0.08), transparent 70%);
            pointer-events: none;
        }
        .header h1 {
            font-family: var(--font-mono);
            font-size: 1.8em;
            font-weight: 700;
            letter-spacing: -0.5px;
            color: #fff;
            margin-bottom: 4px;
        }
        .header-sub { color: var(--text-secondary); font-size: 0.9em; }
        .header-controls {
            display: flex; gap: 12px; margin-top: 16px;
            flex-wrap: wrap; align-items: center;
        }
        .header-controls select, .header-controls .btn {
            background: rgba(255,255,255,0.06);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            font-family: var(--font-sans);
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.15s;
        }
        .header-controls select:hover, .header-controls .btn:hover {
            border-color: var(--green);
            background: rgba(63,185,80,0.08);
        }
        .btn-primary {
            background: var(--green) !important;
            color: #000 !important;
            border-color: var(--green) !important;
            font-weight: 600;
        }
        .btn-primary:hover { opacity: 0.9; }
        .visit-count {
            font-family: var(--font-mono);
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-left: auto;
        }

        /* ===== INPUT SECTION ===== */
        .input-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 24px;
            margin-bottom: 24px;
        }
        .input-tabs {
            display: flex; gap: 4px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 20px;
        }
        .tab-btn {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-family: var(--font-sans);
            font-size: 0.95em;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-btn.active { color: var(--green); border-bottom-color: var(--green); }
        .tab-btn:hover:not(.active) { color: var(--text-secondary); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .input-row { display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap; }
        .input-field { flex: 1; min-width: 200px; }
        .input-field label {
            display: block;
            font-size: 0.82em;
            color: var(--text-secondary);
            margin-bottom: 6px;
            font-weight: 500;
        }
        .input-field input, .input-field textarea, .input-field select {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-family: var(--font-sans);
            font-size: 0.95em;
            transition: border-color 0.15s;
        }
        .input-field input:focus, .input-field textarea:focus {
            outline: none;
            border-color: var(--green);
        }
        .checkbox-row { display: flex; gap: 16px; flex-wrap: wrap; padding: 8px 0; }
        .checkbox-item {
            display: flex; align-items: center; gap: 8px;
            font-size: 0.95em; cursor: pointer;
        }
        .checkbox-item input[type="checkbox"] {
            width: 18px; height: 18px;
            accent-color: var(--green);
            cursor: pointer;
        }
        .submit-btn {
            background: var(--green);
            color: #000;
            padding: 10px 28px;
            border: none;
            border-radius: var(--radius-sm);
            font-family: var(--font-sans);
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            margin-top: 16px;
        }
        .submit-btn:hover { opacity: 0.85; transform: translateY(-1px); }

        /* ===== KIRRUNG CARDS GRID ===== */
        .kirrungen-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(520px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .kirrung-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 24px;
            transition: border-color 0.2s;
        }
        .kirrung-card:hover { border-color: rgba(63,185,80,0.3); }

        .kirrung-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .kirrung-name {
            font-family: var(--font-mono);
            font-size: 1.25em;
            font-weight: 700;
            letter-spacing: -0.3px;
        }

        .ampel {
            width: 32px; height: 32px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.9em;
        }
        .ampel-gruen {
            background: var(--green);
            box-shadow: 0 0 16px var(--green-glow);
        }
        .ampel-rot {
            background: var(--red);
            box-shadow: 0 0 16px rgba(248,81,73,0.4);
        }

        .kirr-status {
            padding: 10px 14px;
            border-radius: var(--radius-sm);
            font-size: 0.88em;
            margin-bottom: 16px;
            border-left: 3px solid;
        }
        .kirr-status.ok {
            background: var(--green-dim);
            border-color: var(--green);
            color: var(--green);
        }
        .kirr-status.warn {
            background: var(--red-dim);
            border-color: var(--red);
            color: var(--red);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-light);
            font-size: 0.88em;
        }
        .stat-label { color: var(--text-secondary); }
        .stat-val {
            font-family: var(--font-mono);
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Stats section within card */
        .card-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 16px 0;
        }
        .stat-box {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 14px;
        }
        .stat-box h4 {
            font-size: 0.8em;
            color: var(--green);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            font-family: var(--font-mono);
        }
        .bar-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
            font-size: 0.8em;
        }
        .bar-label {
            width: 28px;
            text-align: right;
            color: var(--text-muted);
            font-family: var(--font-mono);
            font-size: 0.85em;
        }
        .bar-track {
            flex: 1;
            height: 16px;
            background: rgba(255,255,255,0.03);
            border-radius: 3px;
            overflow: hidden;
        }
        .bar-fill {
            height: 100%;
            background: var(--green);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 6px;
            font-family: var(--font-mono);
            font-size: 0.75em;
            color: #000;
            font-weight: 600;
            min-width: 18px;
            transition: width 0.4s ease;
        }

        /* Phases section */
        .phases-section {
            margin: 16px 0;
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 14px;
        }
        .phases-section h4 {
            font-size: 0.8em;
            color: var(--green);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            font-family: var(--font-mono);
        }
        .phase-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-light);
            font-size: 0.85em;
        }
        .phase-row:last-child { border-bottom: none; }
        .phase-name { color: var(--text-secondary); }
        .phase-name .phase-def {
            font-size: 0.8em;
            color: var(--text-muted);
        }
        .phase-val {
            font-family: var(--font-mono);
            font-weight: 600;
        }
        .phase-val.hot { color: var(--red); }
        .phase-val.normal { color: var(--yellow); }
        .phase-val.low { color: var(--text-muted); }

        /* Wind Factors within card */
        .wind-factors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin: 16px 0;
        }
        .wind-box {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 14px;
        }
        .wind-box h4 {
            font-size: 0.8em;
            color: var(--green);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            font-family: var(--font-mono);
        }
        .wind-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
            font-size: 0.85em;
        }
        .wind-dir {
            width: 24px;
            text-align: right;
            font-family: var(--font-mono);
            font-weight: 600;
            color: var(--text-secondary);
        }
        .wind-bar-track {
            flex: 1; height: 22px;
            background: rgba(255,255,255,0.03);
            border-radius: 4px;
            overflow: hidden;
        }
        .wind-bar-fill {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
            font-family: var(--font-mono);
            font-size: 0.8em;
            font-weight: 600;
            color: #fff;
            border-radius: 4px;
            transition: width 0.4s ease;
        }
        .wind-positive { background: linear-gradient(90deg, var(--green), #4ade80); }
        .wind-negative { background: linear-gradient(90deg, var(--red), #fb7185); }
        .wind-neutral { background: var(--text-muted); }

        /* Hazard Model */
        .hazard-section {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 14px;
            margin-top: 12px;
        }
        .hazard-section h4 {
            font-family: var(--font-mono);
            font-size: 0.8em;
            color: var(--green);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }
        .hazard-row {
            display: flex; align-items: center; gap: 8px;
            margin-bottom: 4px; font-size: 0.85em;
        }
        .hazard-t { 
            width: 42px; text-align: right;
            font-family: var(--font-mono); color: var(--text-muted); 
            font-size: 0.85em;
        }
        .hazard-bar-track {
            flex: 1; height: 16px;
            background: rgba(255,255,255,0.03);
            border-radius: 3px; overflow: hidden;
        }
        .hazard-bar-fill {
            height: 100%; border-radius: 3px;
            display: flex; align-items: center;
            justify-content: flex-end; padding-right: 6px;
            font-family: var(--font-mono); font-size: 0.75em;
            font-weight: 600; color: #fff;
            transition: width 0.3s;
        }
        .hazard-hot { background: linear-gradient(90deg, var(--red), #fb7185); }
        .hazard-warm { background: linear-gradient(90deg, var(--yellow), #fbbf24); }
        .hazard-cool { background: linear-gradient(90deg, var(--green), #4ade80); }
        .hazard-cold { background: var(--text-muted); }
        
        .odds-section {
            margin-top: 12px;
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .odds-item {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.02);
            border-radius: var(--radius-sm);
            font-size: 0.85em;
        }
        .odds-dir { font-family: var(--font-mono); font-weight: 600; width: 20px; }
        .odds-val { font-family: var(--font-mono); }
        .odds-pos { color: var(--green); }
        .odds-neg { color: var(--red); }
        .odds-ref { color: var(--text-muted); font-style: italic; }
        
        .model-params {
            font-size: 0.75em; color: var(--text-muted);
            font-family: var(--font-mono);
            margin-top: 8px; padding-top: 8px;
            border-top: 1px solid var(--border-light);
        }

        .forecast-summary {
            background: rgba(63,185,80,0.08);
            border: 1px solid rgba(63,185,80,0.2);
            border-radius: var(--radius-sm);
            padding: 10px 14px;
            margin-bottom: 12px;
            font-family: var(--font-mono);
            font-size: 0.9em;
            display: flex; justify-content: space-between;
            align-items: center;
        }
        .forecast-summary-label { color: var(--text-secondary); }
        .forecast-summary-val { font-weight: 700; font-size: 1.2em; }

        /* Forecast */
        .forecast-section { margin-top: 16px; }
        .forecast-title {
            font-family: var(--font-mono);
            font-size: 0.8em;
            color: var(--green);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        .forecast-item {
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            padding: 12px 14px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: border-color 0.15s;
        }
        .forecast-item:hover { border-color: rgba(63,185,80,0.2); }
        .forecast-left { flex: 1; }
        .forecast-date {
            font-family: var(--font-mono);
            font-weight: 600;
            font-size: 0.9em;
        }
        .forecast-meta {
            font-size: 0.8em;
            color: var(--text-muted);
            margin-top: 2px;
            display: flex; gap: 12px;
        }
        .forecast-prob {
            font-family: var(--font-mono);
            font-size: 1.4em;
            font-weight: 700;
        }
        .prob-high { color: var(--green); }
        .prob-medium { color: var(--yellow); }
        .prob-low { color: var(--red); }

        /* ===== MODAL ===== */
        .modal-overlay {
            display: none;
            position: fixed; z-index: 1000;
            inset: 0;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
        }
        .modal-overlay.show { display: flex; align-items: center; justify-content: center; }
        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 28px;
            width: 90%;
            max-width: 560px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal h2 {
            font-family: var(--font-mono);
            font-size: 1.1em;
            color: var(--green);
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }
        .modal-field {
            margin-bottom: 14px;
        }
        .modal-field label {
            display: block;
            font-size: 0.82em;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }
        .modal-field input, .modal-field select {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-family: var(--font-sans);
            font-size: 0.95em;
        }
        .modal-btns {
            display: flex; gap: 12px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        .modal-btns .btn {
            padding: 10px 24px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-family: var(--font-sans);
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-cancel { background: transparent; color: var(--text-secondary); }
        .btn-cancel:hover { border-color: var(--red); color: var(--red); }
        .btn-save { background: var(--green); color: #000; font-weight: 600; border-color: var(--green); }
        .btn-save:hover { opacity: 0.85; }

        /* Loading */
        #loading {
            text-align: center;
            padding: 80px 20px;
            font-family: var(--font-mono);
            color: var(--text-secondary);
        }
        .spinner {
            display: inline-block;
            width: 24px; height: 24px;
            border: 3px solid var(--border);
            border-top-color: var(--green);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 16px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Responsive */
        @media (max-width: 1100px) {
            .kirrungen-grid { grid-template-columns: 1fr; }
        }
        @media (max-width: 768px) {
            body { padding: 12px; }
            .card-stats, .wind-factors { grid-template-columns: 1fr; }
            .stat-grid { grid-template-columns: 1fr; }
            .input-row { flex-direction: column; }
        }
    </style>
</head>
<body>
<div class="container">
    <!-- HEADER -->
    <div class="header">
        <h1>üêó Schwarzwild Dashboard</h1>
        <div class="header-sub" id="currentDate"></div>
        <div class="header-controls">
            <select id="zeitraumFilter">
                <option value="all">Alle Daten</option>
                <option value="12m">Letzte 12 Monate</option>
                <option value="3m" selected>Letzte 3 Monate</option>
                <option value="1m">Letzter Monat</option>
            </select>
            <button class="btn btn-primary" onclick="loadData()">‚Üª Aktualisieren</button>
            <span class="visit-count" id="visitCount"></span>
        </div>
    </div>

    <!-- LOADING -->
    <div id="loading">
        <div class="spinner"></div>
        <div>Lade Daten aus Google Sheets...</div>
    </div>

    <!-- MAIN -->
    <div id="main" style="display:none;">
        <!-- EINGABE -->
        <div class="input-section">
            <div class="input-tabs">
                <button class="tab-btn active" onclick="switchTab('besuch')">üêó Schwarzwild-Besuch</button>
                <button class="tab-btn" onclick="switchTab('kirr')">üåΩ Kirrung best√ºckt</button>
            </div>
            <div id="tabBesuch" class="tab-content active">
                <div class="input-row">
                    <div class="input-field" style="flex:3;">
                        <label>Nat√ºrliche Eingabe</label>
                        <input type="text" id="textInput" placeholder="3 Sauen S√§gm√ºhle von 21:30 bis 22:15">
                    </div>
                </div>
                <button class="submit-btn" onclick="parseAndReview()">üîç Eingabe pr√ºfen</button>
            </div>
            <div id="tabKirr" class="tab-content">
                <div class="input-row">
                    <div class="input-field" style="flex:0 0 200px;">
                        <label>Datum</label>
                        <input type="date" id="kirrDatum">
                    </div>
                </div>
                <div class="input-field" style="margin-top:12px;">
                    <label>Welche Kirrungen best√ºckt?</label>
                    <div class="checkbox-row" id="kirrCheckboxes"></div>
                </div>
                <button class="submit-btn" onclick="submitKirrung()">üíæ Best√ºckung speichern</button>
            </div>
        </div>

        <!-- KIRRUNG-KARTEN -->
        <div class="kirrungen-grid" id="kirrungen"></div>
    </div>
</div>

<!-- REVIEW MODAL -->
<div class="modal-overlay" id="reviewModal">
    <div class="modal">
        <h2>üìã Eingabe √ºberpr√ºfen</h2>
        <div id="reviewFields"></div>
        <div class="modal-btns">
            <button class="btn btn-cancel" onclick="closeModal()">‚úï Abbrechen</button>
            <button class="btn btn-save" onclick="saveFromReview()">üíæ Speichern</button>
        </div>
    </div>
</div>

<script>
// ============================================================
// KONFIGURATION
// ============================================================
const API_URL = 'https://script.google.com/macros/s/AKfycbxnhNm66KDiATKiIMkA4wUNnNhe8lQ6-Ki6FWj6WeQKNO9kMdhNdT4qWE_ApjATpzTcfg/exec';
const KIRRUNGEN = ['S√§gm√ºhle', 'Horlacher', 'Tiersbach', 'Gehrlesklinge', 'Ostwind', 'Feuchterswald'];

let allData = [], wetterBaseline = [], filteredBesuche = [], kirrbestueckungen = [], forecastNaechte = [];

// ============================================================
// INIT
// ============================================================
document.addEventListener('DOMContentLoaded', () => {
    const heute = new Date();
    document.getElementById('currentDate').textContent = formatDatum(heute);
    document.getElementById('kirrDatum').valueAsDate = heute;
    
    // Kirrung-Checkboxen generieren
    document.getElementById('kirrCheckboxes').innerHTML = KIRRUNGEN.map(k => `
        <label class="checkbox-item">
            <input type="checkbox" data-kirr="${k}">
            ${k}
        </label>
    `).join('');
    
    document.getElementById('zeitraumFilter').addEventListener('change', () => applyFilter());
    loadData();
});

// ============================================================
// DATEN LADEN
// ============================================================
async function loadData() {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('main').style.display = 'none';
    
    try {
        const resp = await fetch(API_URL);
        const json = await resp.json();
        if (!json.success) throw new Error(json.error);
        
        allData = (json.data || []).map(parseEintrag);
        wetterBaseline = json.wetter_baseline || [];
        forecastNaechte = json.forecast_naechte || [];
        
        console.log(`‚úÖ ${allData.length} Eintr√§ge, ${wetterBaseline.length} Wetter-Tage`);
        if (forecastNaechte.length > 0) {
            console.log('üå§Ô∏è Echte Wettervorhersage:', forecastNaechte.map(n => 
                `${n.nacht_label} ${n.windrichtung} ${n.temperatur}¬∞C ${n.mondphase} ${n.mond_illumination}%`
            ));
        } else {
            console.warn('‚ö†Ô∏è Keine Wettervorhersage vom Backend');
        }
        
        // Diagnostik: stunde_von Extraktion pr√ºfen
        const besuche = allData.filter(d => d.art === 'Kirrbesuch');
        const mitStunde = besuche.filter(d => d.stunde_von !== null && d.stunde_von !== undefined);
        const ohneStunde = besuche.filter(d => d.stunde_von === null || d.stunde_von === undefined);
        console.log(`üîç Uhrzeiten: ${mitStunde.length}/${besuche.length} Besuche haben stunde_von`);
        if (ohneStunde.length > 0) {
            console.warn('‚ö†Ô∏è Besuche OHNE stunde_von:', ohneStunde.slice(0,3).map(d => ({
                uhrzeit_von: d.uhrzeit_von, 
                type: typeof d.uhrzeit_von,
                stunde_von: d.stunde_von,
                ort: d.ort
            })));
        }
        console.log('üìã Erste 5 Besuche:', besuche.slice(0,5).map(d => ({
            stunde_von: d.stunde_von, 
            uhrzeit_von: d.uhrzeit_von, 
            uhrzeit_type: typeof d.uhrzeit_von,
            ort: d.ort
        })));
        
        applyFilter();
    } catch (err) {
        console.error('Fehler:', err);
        document.getElementById('loading').innerHTML = `
            <div style="color:var(--red)">‚úï Fehler beim Laden: ${err.message}</div>
            <div style="color:var(--text-muted);margin-top:8px;font-size:0.85em">
                Pr√ºfe die API_URL im Script und das Google Apps Script Deployment.
            </div>`;
    }
}

function parseEintrag(item) {
    let datum = item.datum_nacht || item.datum;
    if (!datum) return { ...item, datum_parsed: null };
    
    if (typeof datum === 'string') {
        datum = new Date(datum);
    } else if (typeof datum === 'number') {
        datum = new Date((datum - 25569) * 86400000);
    }
    
    if (!(datum instanceof Date) || isNaN(datum.getTime())) {
        return { ...item, datum_parsed: null };
    }
    
    // "Horlacherkirre" ‚Üí "Horlacher"
    let ort = item.ort || '';
    if (ort.toLowerCase().includes('horlacherkirre')) ort = 'Horlacher';
    
    // STUNDE EXTRAHIEREN - hier einmal, f√ºr alle Nutzungen
    // Versuche ALLES: Backend-Feld, dann uhrzeit_von in jedem Format
    let stunde_von = extractStunde(item.stunde_von, item.uhrzeit_von);
    
    return { ...item, datum_parsed: datum, ort, stunde_von };
}

// Extrahiert Stunde (0-23) aus JEDEM denkbaren Format
function extractStunde(backendStunde, uhrzeitVon) {
    // 1. Backend hat schon Integer geliefert?
    if (typeof backendStunde === 'number' && backendStunde >= 0 && backendStunde <= 23) {
        return Math.floor(backendStunde);
    }
    
    if (!uhrzeitVon && uhrzeitVon !== 0) return null;
    
    // 2. Zahl: Serielle Zeit (0.0-0.999) oder direkte Stunde (0-23)
    if (typeof uhrzeitVon === 'number') {
        if (uhrzeitVon >= 0 && uhrzeitVon < 1) return Math.floor(uhrzeitVon * 24);
        if (uhrzeitVon >= 0 && uhrzeitVon <= 23) return Math.floor(uhrzeitVon);
        return null;
    }
    
    var s = String(uhrzeitVon).trim();
    if (!s || s === 'null' || s === 'undefined') return null;
    
    // 3. ISO: "1899-12-30T01:36:00.000Z" oder "2026-02-11T21:49:00"
    var tIdx = s.indexOf('T');
    if (tIdx > -1) {
        var after = s.substring(tIdx + 1);
        var h = parseInt(after);
        return (isNaN(h) || h < 0 || h > 23) ? null : h;
    }
    
    // 4. "HH:mm" oder "HH:mm:ss" oder "H:mm"
    var colonIdx = s.indexOf(':');
    if (colonIdx > -1) {
        var h = parseInt(s.substring(0, colonIdx));
        return (isNaN(h) || h < 0 || h > 23) ? null : h;
    }
    
    // 5. Serielle als String: "0.06667"
    var num = parseFloat(s);
    if (!isNaN(num) && num >= 0 && num < 1) return Math.floor(num * 24);
    
    // 6. Direkte Stunde als String: "21"
    var direct = parseInt(s);
    if (!isNaN(direct) && direct >= 0 && direct <= 23) return direct;
    
    return null;
}

// ============================================================
// ZEITRAUM FILTER
// ============================================================
function applyFilter() {
    const zf = document.getElementById('zeitraumFilter').value;
    const heute = new Date();
    let startDate = new Date(0);
    
    if (zf === '1m') { startDate = new Date(heute); startDate.setMonth(startDate.getMonth() - 1); }
    else if (zf === '3m') { startDate = new Date(heute); startDate.setMonth(startDate.getMonth() - 3); }
    else if (zf === '12m') { startDate = new Date(heute); startDate.setFullYear(startDate.getFullYear() - 1); }
    
    const mitDatum = allData.filter(d => d.datum_parsed);
    
    filteredBesuche = mitDatum.filter(d =>
        d.art === 'Kirrbesuch' && d.datum_parsed >= startDate
    );
    
    kirrbestueckungen = mitDatum.filter(d => d.art === 'Kirrbest√ºckung');
    
    const zeitraumTage = zf === '1m' ? 30 : zf === '3m' ? 90 : zf === '12m' ? 365 :
        Math.max(1, Math.floor((heute - startDate) / 86400000));
    
    renderDashboard(zeitraumTage, startDate);
}

// ============================================================
// DASHBOARD RENDERN
// ============================================================
function renderDashboard(zeitraumTage, startDate) {
    document.getElementById('loading').style.display = 'none';
    document.getElementById('main').style.display = 'block';
    document.getElementById('visitCount').textContent = `${filteredBesuche.length} Besuche im Zeitraum`;
    
    document.getElementById('kirrungen').innerHTML = KIRRUNGEN.map(k =>
        renderKirrungCard(k, zeitraumTage, startDate)
    ).join('');
}

// ============================================================
// KIRRUNG-KARTE
// ============================================================
function renderKirrungCard(kirrung, zeitraumTage, startDate) {
    const besuche = filteredBesuche.filter(d => matchOrt(d.ort, kirrung));
    const besucheMitUhrzeit = besuche.filter(d => d.stunde_von !== null && d.stunde_von !== undefined);
    
    // Nacht-Daten f√ºr Berechnungen
    const nachtDaten = besucheMitUhrzeit.map(d => getNachtDatum(d)).sort((a, b) => a - b);
    
    // Grundstatistiken
    const status = getAmpelStatus(kirrung, besuche);
    const letzterBesuch = getLetzterBesuch(nachtDaten);
    
    // Pausen + Durchschnitt (deskriptiv)
    const pausen = berechnePausen(nachtDaten);
    const durchschnittPause = berechneDurchschnittPause(pausen);
    
    // ‚òÖ HAZARD-MODELL fitten (pro Kirrung, pro Zeitraum)
    const model = fitHazardModel(besucheMitUhrzeit, nachtDaten, zeitraumTage, startDate);
    
    // Forecast mit Hazard-Modell
    const forecast = berechneForecast(kirrung, nachtDaten, model, zeitraumTage);
    
    // Kumulierte 4-N√§chte Wahrscheinlichkeit
    const cumProb = forecast.length > 0 && forecast[0].prob > 0
        ? Math.round((1 - forecast.reduce((prod, f) => prod * (1 - f.prob / 100), 1)) * 100)
        : 0;
    
    // Wochentag-Statistik / Uhrzeiten (bleiben deskriptiv)
    const wochentage = berechneWochentage(nachtDaten);
    const uhrzeiten = berechneUhrzeiten(besucheMitUhrzeit);
    
    // h(t=1) bei S-Wind als Headline-Stat
    const sWind = { N: 0, S: 1, O: 0, W: 0 };
    const hPeak = model ? hazardPredict(model, 1, sWind, 0) : 0;
    
    return `
    <div class="kirrung-card">
        <div class="kirrung-header">
            <div class="kirrung-name">${kirrung}</div>
            <div class="ampel ${status.ampelClass}">${status.icon}</div>
        </div>
        <div class="kirr-status ${status.statusClass}">${status.text}</div>
        
        <div class="stat-grid">
            <div class="stat-item">
                <span class="stat-label">Gesamt-Besuche</span>
                <span class="stat-val">${besuche.length}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Letzter Besuch</span>
                <span class="stat-val">${letzterBesuch}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Letzte Best√ºckung</span>
                <span class="stat-val">${status.letzteKirr}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Median-Pause</span>
                <span class="stat-val">${model ? model.medianPause + 'N' : '‚Äì'}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚åÄ Pause</span>
                <span class="stat-val">${durchschnittPause > 0 ? durchschnittPause.toFixed(1) + 'N' : '‚Äì'}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">h(t=1) Peak</span>
                <span class="stat-val" style="color:var(--red)">${hPeak.toFixed(1)}%</span>
            </div>
        </div>
        
        <div class="card-stats">
            <div class="stat-box">
                <h4>üìÖ Wochentage</h4>
                ${wochentage}
            </div>
            <div class="stat-box">
                <h4>üïê Uhrzeiten (18‚Äì06h)</h4>
                ${uhrzeiten}
            </div>
        </div>
        
        ${renderHazardModel(model, durchschnittPause)}
        
        <div class="forecast-section">
            <div class="forecast-title">üìä 4-N√§chte Forecast (Hazard-Modell)</div>
            <div class="forecast-summary">
                <span class="forecast-summary-label">P(‚â•1 Besuch in 4 N√§chten)</span>
                <span class="forecast-summary-val ${cumProb >= 50 ? 'prob-high' : cumProb >= 20 ? 'prob-medium' : 'prob-low'}">${cumProb}%</span>
            </div>
            ${forecast.map(f => {
                const w = f.wetter;
                const wetterLine = w ? `${w.temperatur != null ? w.temperatur + '¬∞C' : ''} ${w.niederschlag != null && w.niederschlag > 0 ? 'üåß ' + w.niederschlag + 'mm' : ''}` : '';
                const mondLine = w ? `${w.mond_emoji || ''} ${w.mondphase || ''} ${w.mond_illumination != null ? w.mond_illumination + '%' : ''}` : '';
                const windLine = w ? `üí® ${w.windrichtung} (${w.windrichtung_grad}¬∞) ${w.windgeschwindigkeit != null ? w.windgeschwindigkeit + ' km/h' : ''}` : `üí® ${f.wind}`;
                return `
                <div class="forecast-item">
                    <div class="forecast-left">
                        <div class="forecast-date">${f.label}</div>
                        <div class="forecast-meta">
                            <span>${windLine}</span>
                            <span>${wetterLine}</span>
                        </div>
                        <div class="forecast-meta">
                            <span>${mondLine}</span>
                            <span>${f.hinweis}</span>
                        </div>
                    </div>
                    <div class="forecast-prob ${f.probClass}">${f.prob}%</div>
                </div>`;
            }).join('')}
        </div>
    </div>`;
}

// ============================================================
// NACHT-DATUM NORMALISIERUNG
// datum_parsed kommt aus datum_nacht (Sheet) ‚Üí bereits korrekt!
// Hier NUR auf Mitternacht normalisieren, KEINE Uhrzeit-Korrektur!
// ============================================================
function getNachtDatum(eintrag) {
    const d = new Date(eintrag.datum_parsed);
    d.setHours(0, 0, 0, 0);
    return d;
}

function parseStunde(uhrzeit) {
    if (!uhrzeit && uhrzeit !== 0) return null;
    
    // Fall 1: Bereits eine Zahl
    if (typeof uhrzeit === 'number') {
        // Serielle Zeit (0.0 - 0.9999) ‚Üí Stunde = Math.floor(zahl * 24)
        if (uhrzeit >= 0 && uhrzeit < 1) {
            return Math.floor(uhrzeit * 24);
        }
        // Direkte Stunde (0-23)
        if (uhrzeit >= 0 && uhrzeit <= 23 && Number.isInteger(uhrzeit)) {
            return uhrzeit;
        }
        return null;
    }
    
    const str = uhrzeit.toString().trim();
    if (!str) return null;
    
    // Fall 2: ISO-Format "1899-12-30T01:36:00.000Z" oder "2026-02-11T21:49:00"
    if (str.includes('T')) {
        const timePart = str.split('T')[1];
        if (timePart) {
            const h = parseInt(timePart.split(':')[0]);
            return isNaN(h) ? null : h;
        }
    }
    
    // Fall 3: "HH:mm" oder "HH:mm:ss" oder "H:mm"
    if (str.includes(':')) {
        const h = parseInt(str.split(':')[0]);
        return isNaN(h) ? null : h;
    }
    
    // Fall 4: Serielle Zeit als String "0.06667"
    const num = parseFloat(str);
    if (!isNaN(num) && num >= 0 && num < 1) {
        return Math.floor(num * 24);
    }
    
    // Fall 5: Nur eine Zahl als String "21"
    const direkteStunde = parseInt(str);
    if (!isNaN(direkteStunde) && direkteStunde >= 0 && direkteStunde <= 23) {
        return direkteStunde;
    }
    
    return null;
}

// ============================================================
// PAUSEN BERECHNEN
// ============================================================
function berechnePausen(nachtDatenSorted) {
    if (nachtDatenSorted.length < 2) return [];
    
    // Deduplizieren: gleiche Nacht nur einmal z√§hlen
    const unique = [];
    for (const d of nachtDatenSorted) {
        if (unique.length === 0 || (d - unique[unique.length - 1]) >= 86400000) {
            unique.push(d);
        }
    }
    
    const pausen = [];
    for (let i = 1; i < unique.length; i++) {
        const diff = Math.round((unique[i] - unique[i - 1]) / 86400000);
        if (diff > 0) pausen.push(diff);
    }
    return pausen;
}

function berechneDurchschnittPause(pausen) {
    // Nur Pausen > 3 N√§chte (au√üerhalb Hot-Zone) f√ºr Durchschnitt
    const relevantePausen = pausen.filter(p => p > 3);
    if (relevantePausen.length === 0) return pausen.length > 0 ? pausen.reduce((a, b) => a + b, 0) / pausen.length : 0;
    return relevantePausen.reduce((a, b) => a + b, 0) / relevantePausen.length;
}

// ============================================================
// PHASEN-WAHRSCHEINLICHKEITEN (KERNLOGIK!)
// ============================================================
function berechnePhasen(pausen, zeitraumTage, durchschnitt) {
    if (pausen.length === 0 || zeitraumTage === 0) {
        return { phase1: 0, phase2: 0, phase3: 0, phase4: 0, phase234avg: 0,
                 phase1_naechte: 0, phase2_naechte: 0, phase3_naechte: 0, phase4_naechte: 0 };
    }
    
    // Phase 1: Hot-Zone = 1-3 N√§chte nach Besuch
    // Phase 2: Normal = 4 bis Durchschnitt
    // Phase 3: √úberf√§llig = Durchschnitt bis 2√óDurchschnitt
    // Phase 4: Vergessen = > 2√óDurchschnitt
    
    const grenze2 = Math.max(4, Math.round(durchschnitt));
    const grenze3 = Math.round(durchschnitt * 2);
    
    let p1_naechte = 0, p2_naechte = 0, p3_naechte = 0, p4_naechte = 0;
    
    pausen.forEach(pause => {
        // F√ºr jede Pause: Wie viele N√§chte fallen in welche Phase?
        for (let nacht = 1; nacht <= pause; nacht++) {
            if (nacht <= 3) {
                p1_naechte++;
            } else if (nacht <= grenze2) {
                p2_naechte++;
            } else if (nacht <= grenze3) {
                p3_naechte++;
            } else {
                p4_naechte++;
            }
        }
    });
    
    // Wahrscheinlichkeit = Anzahl Besuche die in Phase fallen / Gesamt-N√§chte im Zeitraum
    // "Anzahl Pausen (N√§chte) bis zum Besuch in der Phase / Gesamt N√§chte (Zeitraum)"
    // ‚Üí Wie oft endet eine Pause in dieser Phase, geteilt durch Gesamtzeitraum
    
    let p1_besuche = 0, p2_besuche = 0, p3_besuche = 0, p4_besuche = 0;
    pausen.forEach(pause => {
        if (pause <= 3) p1_besuche++;
        else if (pause <= grenze2) p2_besuche++;
        else if (pause <= grenze3) p3_besuche++;
        else p4_besuche++;
    });
    
    // P/Nacht = Besuche in Phase / Anzahl N√§chte in Phase
    // ‚Üí Wenn ich in Phase X bin, wie wahrscheinlich kommt DIESE Nacht ein Besuch?
    const phase1 = p1_naechte > 0 ? (p1_besuche / p1_naechte) * 100 : 0;
    const phase2 = p2_naechte > 0 ? (p2_besuche / p2_naechte) * 100 : 0;
    const phase3 = p3_naechte > 0 ? (p3_besuche / p3_naechte) * 100 : 0;
    const phase4 = p4_naechte > 0 ? (p4_besuche / p4_naechte) * 100 : 0;
    
    // Durchschnitt Phase 2-4
    const total234 = p2_naechte + p3_naechte + p4_naechte;
    const phase234avg = total234 > 0 ? ((p2_besuche + p3_besuche + p4_besuche) / total234) * 100 : 0;
    
    return {
        phase1, phase2, phase3, phase4, phase234avg,
        phase1_naechte: p1_naechte, phase2_naechte: p2_naechte,
        phase3_naechte: p3_naechte, phase4_naechte: p4_naechte,
        p1_besuche, p2_besuche, p3_besuche, p4_besuche,
        grenze2, grenze3
    };
}

function renderPhasen(phasen, durchschnitt) {
    const g2 = phasen.grenze2 || Math.round(durchschnitt);
    const g3 = phasen.grenze3 || Math.round(durchschnitt * 2);
    
    return `
    <div class="phases-section">
        <h4>üìà Phasen-Wahrscheinlichkeit</h4>
        <div class="phase-row">
            <span class="phase-name">Phase 1: üî• Hot-Zone <span class="phase-def">(1‚Äì3 N√§chte)</span></span>
            <span class="phase-val hot">${phasen.phase1.toFixed(1)}% /Nacht</span>
        </div>
        <div class="phase-row">
            <span class="phase-name">Phase 2: Normal <span class="phase-def">(4‚Äì${g2} N√§chte)</span></span>
            <span class="phase-val normal">${phasen.phase2.toFixed(1)}% /Nacht</span>
        </div>
        <div class="phase-row">
            <span class="phase-name">Phase 3: √úberf√§llig <span class="phase-def">(${g2+1}‚Äì${g3} N√§chte)</span></span>
            <span class="phase-val normal">${phasen.phase3.toFixed(1)}% /Nacht</span>
        </div>
        <div class="phase-row">
            <span class="phase-name">Phase 4: Vergessen <span class="phase-def">(>${g3} N√§chte)</span></span>
            <span class="phase-val low">${phasen.phase4.toFixed(1)}% /Nacht</span>
        </div>
    </div>`;
}

// ============================================================
// WIND-FAKTOREN (LIKELIHOOD RATIO)
// ============================================================
// Wind-Hauptrichtung f√ºr Anzeige (Display-Zweck)
function gruppiereWind(windStr) {
    if (!windStr) return null;
    const w = windStr.toString().replace(/\(.*\)/, '').trim().toUpperCase();
    if (w === 'N') return 'N';
    if (w === 'S') return 'S';
    if (w === 'O' || w === 'NO' || w === 'SO') return 'O';
    if (w === 'W' || w === 'NW' || w === 'SW') return 'W';
    for (const r of ['NW','NO','SW','SO','N','O','S','W']) {
        if (w.includes(r)) {
            if (r === 'N') return 'N';
            if (r === 'S') return 'S';
            if (r === 'O' || r === 'NO' || r === 'SO') return 'O';
            if (r === 'W' || r === 'NW' || r === 'SW') return 'W';
        }
    }
    return null;
}

// Wind-Gewichte 50/50 f√ºr Modell: SW ‚Üí {S:0.5, W:0.5}, N ‚Üí {N:1}
function windGewichte(windStr) {
    const leer = { N: 0, S: 0, O: 0, W: 0 };
    if (!windStr) return null;
    const w = windStr.toString().replace(/\(.*\)/, '').trim().toUpperCase();
    
    const map = {
        'N':  { N: 1,   S: 0,   O: 0,   W: 0   },
        'S':  { N: 0,   S: 1,   O: 0,   W: 0   },
        'O':  { N: 0,   S: 0,   O: 1,   W: 0   },
        'W':  { N: 0,   S: 0,   O: 0,   W: 1   },
        'NO': { N: 0.5, S: 0,   O: 0.5, W: 0   },
        'SO': { N: 0,   S: 0.5, O: 0.5, W: 0   },
        'NW': { N: 0.5, S: 0,   O: 0,   W: 0.5 },
        'SW': { N: 0,   S: 0.5, O: 0,   W: 0.5 },
    };
    
    if (map[w]) return map[w];
    
    // Fallback
    for (const r of ['NW','NO','SW','SO','N','O','S','W']) {
        if (w.includes(r) && map[r]) return map[r];
    }
    return null;
}

function berechneWindFaktoren(besucheMitUhrzeit, nachtDaten, zeitraumTage, startDate, phaseType, durchschnitt) {
    const unique = deduplicateNachtDaten(nachtDaten);
    
    const relevanteBesuche = besucheMitUhrzeit.filter(b => {
        const nd = getNachtDatum(b);
        const idx = unique.findIndex(u => Math.abs(u - nd) < 43200000);
        if (idx < 1) return false;
        const pause = Math.round((unique[idx] - unique[idx - 1]) / 86400000);
        if (phaseType === 'phase1') return pause >= 1 && pause <= 3;
        else return pause > 3;
    });
    
    // Wind-Verteilung mit 50/50-Gewichten
    const windBesuche = { N: 0, S: 0, O: 0, W: 0 };
    let totalBesuche = 0;
    relevanteBesuche.forEach(b => {
        const gew = windGewichte(b.windrichtung);
        if (gew) { 
            windBesuche.N += gew.N; windBesuche.S += gew.S;
            windBesuche.O += gew.O; windBesuche.W += gew.W;
            totalBesuche++;
        }
    });
    
    // Baseline-Wind mit 50/50-Gewichten
    const baselineFiltered = wetterBaseline.filter(w => {
        if (!w.date) return false;
        const d = new Date(w.date);
        return d >= startDate;
    });
    
    const windBaseline = { N: 0, S: 0, O: 0, W: 0 };
    let totalBaseline = 0;
    baselineFiltered.forEach(w => {
        const gew = windGewichte(w.wdir_era5 || w.wdir_dwd);
        if (gew) {
            windBaseline.N += gew.N; windBaseline.S += gew.S;
            windBaseline.O += gew.O; windBaseline.W += gew.W;
            totalBaseline++;
        }
    });
    
    const result = {};
    ['N', 'S', 'O', 'W'].forEach(dir => {
        const pVisit = totalBesuche > 0 ? windBesuche[dir] / totalBesuche : 0;
        const pBase = totalBaseline > 0 ? windBaseline[dir] / totalBaseline : 0;
        result[dir] = pBase > 0 ? pVisit / pBase : 1.0;
    });
    
    return result;
}

function deduplicateNachtDaten(nachtDaten) {
    const unique = [];
    for (const d of nachtDaten) {
        if (unique.length === 0 || (d - unique[unique.length - 1]) >= 86400000) {
            unique.push(d);
        }
    }
    return unique;
}

// ============================================================
// HAZARD-MODELL: 2-Stufen + Sliding Window
// Features: [intercept, exp(-Œª‚ÇÅt), exp(-Œª‚ÇÇt), N, O, W, P_next]
// Wind: 50/50 Gewichte (SW ‚Üí 0.5 S + 0.5 W)
// Blending: Standard ‚Üí Individuell (progressiv ab 3 Besuche)
// ============================================================

function sigmoid(x) {
    if (x > 20) return 1;
    if (x < -20) return 0;
    return 1 / (1 + Math.exp(-x));
}

function medianCalc(arr) {
    if (arr.length === 0) return 0;
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
}

function buildBaselineWindMap() {
    const map = {};
    wetterBaseline.forEach(w => {
        if (w.date) {
            let key;
            if (typeof w.date === 'string') {
                key = w.date.split('T')[0];
            } else {
                try { key = new Date(w.date).toISOString().split('T')[0]; } catch(e) { return; }
            }
            map[key] = w.wdir_era5 || w.wdir_dwd || null;
        }
    });
    return map;
}

// ============================================================
// SLIDING WINDOW: Sequenz-basierte Musteranalyse
// ============================================================
function buildSlidingWindow(unique, fenster) {
    if (!fenster) fenster = 3;
    if (unique.length < 2) return { pNext: {}, seqCounts: {}, timeline: [], dateKeys: [] };
    
    // Bin√§re Timeline: jede Nacht 0 oder 1
    const visitSet = new Set(unique.map(d => d.toISOString().split('T')[0]));
    const first = unique[0];
    const last = unique[unique.length - 1];
    const timeline = [];
    const dateKeys = [];
    
    let cur = new Date(first);
    while (cur <= last) {
        const key = cur.toISOString().split('T')[0];
        timeline.push(visitSet.has(key) ? 1 : 0);
        dateKeys.push(key);
        cur = new Date(cur); cur.setDate(cur.getDate() + 1);
    }
    
    // Sequenz-Statistiken: P(Besuch | letzte 3 N√§chte)
    const seqCounts = {};
    const followCounts = {};
    
    for (let i = 0; i <= timeline.length - fenster - 1; i++) {
        const seq = timeline.slice(i, i + fenster).join('');
        if (seq === '0'.repeat(fenster)) continue; // Reine Leere ignorieren
        const next = timeline[i + fenster];
        seqCounts[seq] = (seqCounts[seq] || 0) + 1;
        followCounts[seq] = (followCounts[seq] || 0) + next;
    }
    
    const pNext = {};
    for (const seq in seqCounts) {
        pNext[seq] = seqCounts[seq] >= 2 ? followCounts[seq] / seqCounts[seq] : 0;
    }
    
    return { pNext, seqCounts, timeline, dateKeys };
}

// P_next f√ºr ein bestimmtes Datum abrufen
function getSlidingFactor(sw, dateKey, fenster) {
    if (!fenster) fenster = 3;
    if (!sw || !sw.dateKeys || sw.dateKeys.length < fenster) return 0;
    
    const idx = sw.dateKeys.indexOf(dateKey);
    if (idx < fenster) return 0;
    
    const seq = sw.timeline.slice(idx - fenster, idx).join('');
    if (seq === '0'.repeat(fenster)) return 0;
    return sw.pNext[seq] || 0;
}

// P_next f√ºr die letzten N N√§chte (f√ºr Forecast in die Zukunft)
function getCurrentSlidingFactor(sw, fenster) {
    if (!fenster) fenster = 3;
    if (!sw || !sw.timeline || sw.timeline.length < fenster) return 0;
    
    const seq = sw.timeline.slice(-fenster).join('');
    if (seq === '0'.repeat(fenster)) return 0;
    return sw.pNext[seq] || 0;
}

// ============================================================
// STANDARDKURVE: Fallback + Blending-Basis
// 7 Features: [Œ≤‚ÇÄ, Œ±‚ÇÅ, Œ±‚ÇÇ, Œ≤_N, Œ≤_O, Œ≤_W, Œ≤_SW]
// ============================================================
const STANDARDKURVE = {
    lambda1: 0.4621,
    lambda2: 0.0866,
    beta: [-2.6295, 1.9401, 0.6103, -0.0861, -0.2355, -0.2454, 0.0],
    // Œ≤_SW = 0: Sliding Window hat keinen Effekt in Standardkurve
    medianPause: 8,
    nVisits: 0,
    nPausen: 0,
    nTraining: 1013,
    halfLife1: 1.5,
    halfLife2: 8,
    pausen: [],
    isStandard: true,
    blendWeight: 0,
    slidingWindow: null
};

/**
 * Fittet das Hazard-Modell pro Kirrung.
 * < 10 Besuche: Standardkurve
 * ‚â• 10 Besuche: Individuelles Modell mit Sliding Window + Wind 50/50
 */
function fitHazardModel(besucheMitUhrzeit, nachtDaten, zeitraumTage, startDate) {
    const unique = deduplicateNachtDaten(nachtDaten);
    
    // < 3 Besuche ‚Üí Standardkurve, kein SW m√∂glich
    if (unique.length < 3) {
        console.log(`‚ö†Ô∏è ${unique.length} Besuche ‚Üí Standardkurve`);
        return { ...STANDARDKURVE, nVisits: unique.length };
    }
    
    // Sliding Window immer aufbauen (f√ºr Anzeige + Forecast)
    const sw = buildSlidingWindow(unique, 3);
    
    // < 10 Besuche ‚Üí Standardkurve (aber mit SW-Daten)
    if (unique.length < 10) {
        console.log(`‚ö†Ô∏è ${unique.length} Besuche ‚Üí Standardkurve (mit SW-Daten)`);
        return { ...STANDARDKURVE, nVisits: unique.length, slidingWindow: sw };
    }
    
    // Pausen berechnen
    const pausen = [];
    for (let i = 1; i < unique.length; i++) {
        pausen.push(Math.round((unique[i] - unique[i-1]) / 86400000));
    }
    if (pausen.length < 2) {
        return { ...STANDARDKURVE, nVisits: unique.length, slidingWindow: sw };
    }
    
    // Kurzzeit-Cluster entfernen f√ºr Rhythmusgr√∂√üe
    const langPausen = pausen.filter(p => p > 3);
    const medPause = langPausen.length >= 2 ? medianCalc(langPausen) : medianCalc(pausen);
    
    // Lambda-Sch√§tzung
    const lambda1 = Math.log(2) / 1.5;
    const lambda2 = Math.log(2) / Math.max(medPause, 2);
    
    // Wind-Lookup Maps (Roh-Strings f√ºr 50/50)
    const windMap = buildBaselineWindMap();
    const visitWindMap = {};
    besucheMitUhrzeit.forEach(b => {
        const nd = getNachtDatum(b);
        const key = nd.toISOString().split('T')[0];
        if (b.windrichtung) visitWindMap[key] = b.windrichtung;
    });
    
    // Training-Daten: 7 Features
    const X = [];
    const y = [];
    
    for (let i = 0; i < pausen.length; i++) {
        const pause = pausen[i];
        const startNacht = unique[i];
        
        for (let t = 1; t <= pause; t++) {
            const nachtDate = new Date(startNacht);
            nachtDate.setDate(nachtDate.getDate() + t);
            const dateKey = nachtDate.toISOString().split('T')[0];
            
            // Wind: 50/50 Gewichte
            const windRaw = (t === pause)
                ? (visitWindMap[dateKey] || windMap[dateKey] || null)
                : (windMap[dateKey] || null);
            const gew = windGewichte(windRaw) || { N: 0, S: 0, O: 0, W: 0 };
            
            // Sliding Window Faktor
            const pNextVal = getSlidingFactor(sw, dateKey, 3);
            
            // Feature-Vektor: [1, exp(-Œª‚ÇÅt), exp(-Œª‚ÇÇt), N, O, W, P_next]
            X.push([
                1,
                Math.exp(-lambda1 * t),
                Math.exp(-lambda2 * t),
                gew.N,
                gew.O,
                gew.W,
                pNextVal
            ]);
            y.push(t === pause ? 1 : 0);
        }
    }
    
    if (X.length < 5) {
        return { ...STANDARDKURVE, nVisits: unique.length, slidingWindow: sw };
    }
    
    // Logistische Regression: 7 Parameter
    const beta = fitLogisticGD(X, y, 0.05, 500, 0.01);
    
    console.log(`üéØ Hazard: Œ≤=[${beta.map(b=>b.toFixed(3))}] ` +
                `Œª‚ÇÅ=${lambda1.toFixed(3)} Œª‚ÇÇ=${lambda2.toFixed(3)} ` +
                `n=${X.length} visits=${unique.length} median=${medPause}`);
    
    return {
        lambda1, lambda2, beta,
        medianPause: medPause,
        nVisits: unique.length,
        nPausen: pausen.length,
        nTraining: X.length,
        halfLife1: 1.5,
        halfLife2: Math.max(medPause, 2),
        pausen: pausen,
        isStandard: false,
        blendWeight: 1,
        slidingWindow: sw
    };
}

function fitLogisticGD(X, y, lr, maxIter, lambdaReg) {
    const n = X.length;
    const p = X[0].length; // 7 Features
    
    // Startwerte
    const beta = new Array(p).fill(0);
    beta[0] = -2;   // Intercept
    beta[1] = 2.5;  // Œ±‚ÇÅ Hot-Zone
    beta[2] = 1.0;  // Œ±‚ÇÇ Rhythmus
    // beta[3-5] = 0 (Wind N, O, W)
    if (p >= 7) beta[6] = 0.5; // Œ≤_SW Sliding Window (leicht positiv)
    
    let bestLL = -Infinity;
    let bestBeta = [...beta];
    
    for (let iter = 0; iter < maxIter; iter++) {
        const grad = new Array(p).fill(0);
        let ll = 0;
        
        for (let i = 0; i < n; i++) {
            let eta = 0;
            for (let j = 0; j < p; j++) eta += beta[j] * X[i][j];
            
            const mu = sigmoid(eta);
            const muSafe = Math.max(1e-10, Math.min(1 - 1e-10, mu));
            
            for (let j = 0; j < p; j++) {
                grad[j] += (y[i] - mu) * X[i][j];
                if (j > 0) grad[j] -= lambdaReg * beta[j];
            }
            
            ll += y[i] * Math.log(muSafe) + (1 - y[i]) * Math.log(1 - muSafe);
        }
        
        const currentLR = lr / (1 + iter * 0.002);
        for (let j = 0; j < p; j++) {
            beta[j] += currentLR * grad[j] / n;
        }
        
        if (ll > bestLL) {
            bestLL = ll;
            bestBeta = [...beta];
        }
    }
    
    return bestBeta;
}

/**
 * Hazard-Vorhersage mit 50/50 Wind-Gewichten + Sliding Window
 * @param {Object} model - Modell-Objekt
 * @param {number} t - N√§chte seit letztem Besuch
 * @param {Object|string} wind - windGewichte-Objekt ODER Richtungsstring (Fallback)
 * @param {number} pNextVal - Sliding Window P_next (0..1)
 */
function hazardPredict(model, t, wind, pNextVal) {
    if (!model || t < 1) return 0;
    const b = model.beta;
    
    // Wind-Gewichte: Objekt oder String
    let gew;
    if (wind && typeof wind === 'object') {
        gew = wind;
    } else {
        gew = windGewichte(wind) || { N: 0, S: 0, O: 0, W: 0 };
    }
    
    let eta = b[0]
        + b[1] * Math.exp(-model.lambda1 * t)
        + b[2] * Math.exp(-model.lambda2 * t)
        + b[3] * gew.N    // 50/50 anteilig
        + b[4] * gew.O
        + b[5] * gew.W;
    
    // Sliding Window Feature (7. Parameter)
    if (b.length >= 7 && pNextVal !== undefined) {
        eta += b[6] * (pNextVal || 0);
    }
    
    return sigmoid(eta) * 100;
}

function renderHazardModel(model, durchschnitt) {
    if (!model) {
        return '<div class="hazard-section"><h4>üìà Hazard-Modell</h4><span style="color:var(--text-muted)">Zu wenig Daten</span></div>';
    }
    
    // Model-Label
    let modelLabel;
    if (model.isStandard) {
        modelLabel = '<span style="color:var(--yellow);font-size:0.8em"> ‚ö†Ô∏è Standardkurve (&lt;10 Besuche)</span>';
    } else {
        modelLabel = '<span style="color:var(--green);font-size:0.8em"> ‚úì Individuell</span>';
    }
    
    // Hazard-Kurve bei S-Wind (Referenz)
    const tValues = [1, 2, 3, 5, Math.round(model.medianPause), Math.round(model.medianPause * 2)];
    const tUnique = [...new Set(tValues)].filter(t => t > 0).sort((a, b) => a - b);
    
    const sWind = { N: 0, S: 1, O: 0, W: 0 };
    const maxProb = hazardPredict(model, 1, sWind, 0);
    
    const curveHTML = tUnique.map(t => {
        const prob = hazardPredict(model, t, sWind, 0);
        const width = maxProb > 0 ? Math.max(2, (prob / maxProb) * 100) : 0;
        const cls = prob >= 35 ? 'hazard-hot' : prob >= 15 ? 'hazard-warm' : prob >= 5 ? 'hazard-cool' : 'hazard-cold';
        const label = t <= 3 ? 'üî•' : t > model.medianPause * 1.5 ? 'üí§' : '';
        return `
            <div class="hazard-row">
                <div class="hazard-t">${t}N</div>
                <div class="hazard-bar-track">
                    <div class="hazard-bar-fill ${cls}" style="width:${width}%">${prob.toFixed(1)}%</div>
                </div>
                <span style="font-size:0.8em">${label}</span>
            </div>`;
    }).join('');
    
    // Wind Odds Ratios
    const oddsN = Math.exp(model.beta[3]);
    const oddsO = Math.exp(model.beta[4]);
    const oddsW = Math.exp(model.beta[5]);
    
    const fmtOdds = (val, dir) => {
        const cls = val > 1.1 ? 'odds-pos' : val < 0.9 ? 'odds-neg' : 'odds-ref';
        const icon = val > 1.3 ? ' üî•' : val < 0.7 ? ' ‚ùÑÔ∏è' : '';
        return `<div class="odds-item"><span class="odds-dir">${dir}</span><span class="odds-val ${cls}">${val.toFixed(2)}√ó${icon}</span></div>`;
    };
    
    const oddsHTML = `
        <div class="odds-section">
            ${fmtOdds(oddsN, 'N')}
            <div class="odds-item"><span class="odds-dir">S</span><span class="odds-val odds-ref">Ref.</span></div>
            ${fmtOdds(oddsO, 'O')}
            ${fmtOdds(oddsW, 'W')}
        </div>`;
    
    // Sliding Window Info
    let swHTML = '';
    const sw = model.slidingWindow;
    if (sw && sw.pNext && Object.keys(sw.pNext).length > 0) {
        const seqs = Object.entries(sw.pNext)
            .filter(([seq, _]) => sw.seqCounts[seq] >= 3)
            .sort((a, b) => b[1] - a[1]);
        
        if (seqs.length > 0) {
            const seqLabels = {
                '111': '3√ó Besuch',
                '110': '2√ó dann Pause',
                '101': 'Alternierend',
                '011': 'Pause ‚Üí 2√ó',
                '100': 'Besuch ‚Üí 2√ó leer',
                '010': 'Einzelbesuch',
                '001': 'Leer ‚Üí Besuch',
            };
            swHTML = `
            <div class="hazard-section" style="margin-top:8px">
                <h4>üîÑ Sliding Window (3-N√§chte Muster)</h4>
                ${seqs.slice(0, 5).map(([seq, p]) => {
                    const label = seqLabels[seq] || seq;
                    const n = sw.seqCounts[seq];
                    const barW = Math.max(5, p * 100);
                    const cls = p >= 0.35 ? 'hazard-hot' : p >= 0.15 ? 'hazard-warm' : 'hazard-cool';
                    return `<div class="hazard-row">
                        <div class="hazard-t" style="width:100px;font-size:0.8em">${label}</div>
                        <div class="hazard-bar-track">
                            <div class="hazard-bar-fill ${cls}" style="width:${barW}%">${(p*100).toFixed(0)}%</div>
                        </div>
                        <span style="font-size:0.75em;color:var(--text-muted)">n=${n}</span>
                    </div>`;
                }).join('')}
                <div class="model-params">Œ≤<sub>SW</sub>=${model.beta.length >= 7 ? model.beta[6].toFixed(3) : '‚Äì'}</div>
            </div>`;
        }
    }
    
    const paramsHTML = `
        <div class="model-params">
            Œª‚ÇÅ=${model.lambda1.toFixed(3)} (t¬Ω=${model.halfLife1.toFixed(1)}N) ¬∑ 
            Œª‚ÇÇ=${model.lambda2.toFixed(3)} (t¬Ω=${model.halfLife2.toFixed(1)}N) ¬∑ 
            Median=${model.medianPause}N ¬∑ 
            n=${model.nTraining}
        </div>`;
    
    return `
        <div class="hazard-section">
            <h4>üìà Hazard-Modell${modelLabel}</h4>
            ${curveHTML}
        </div>
        <div class="hazard-section" style="margin-top:8px">
            <h4>üí® Wind-Einfluss (Odds Ratio, 50/50)</h4>
            ${oddsHTML}
            ${paramsHTML}
        </div>
        ${swHTML}`;
}

function renderWindBars(windFaktoren) {
    return ['N', 'S', 'O', 'W'].map(dir => {
        const ratio = windFaktoren[dir] || 1.0;
        const diff = (ratio - 1.0) * 100;
        const width = Math.min(Math.abs(diff) * 3 + 10, 100);
        const cls = diff > 5 ? 'wind-positive' : diff < -5 ? 'wind-negative' : 'wind-neutral';
        const label = ratio.toFixed(2) + '√ó';
        return `
            <div class="wind-row">
                <div class="wind-dir">${dir}</div>
                <div class="wind-bar-track">
                    <div class="wind-bar-fill ${cls}" style="width:${width}%">${label}</div>
                </div>
            </div>`;
    }).join('');
}

// ============================================================
// FORECAST
// ============================================================
function berechneForecast(kirrung, nachtDaten, model, zeitraumTage) {
    const unique = deduplicateNachtDaten(nachtDaten);
    if (unique.length < 2 || !model) {
        return [{ label: 'Zu wenig Daten', prob: 0, probClass: 'prob-low', wind: '‚Äì', hinweis: 'Min. 3 Besuche n√∂tig', wetter: null }];
    }
    
    const letzterBesuchDatum = unique[unique.length - 1];
    
    // Sliding Window: aktueller Faktor (letzte 3 N√§chte)
    const pNextBase = model.slidingWindow ? getCurrentSlidingFactor(model.slidingWindow, 3) : 0;
    
    const forecast = [];
    for (let i = 0; i < 4; i++) {
        const datum = new Date();
        datum.setDate(datum.getDate() + i);
        datum.setHours(0, 0, 0, 0);
        
        const morgen = new Date(datum);
        morgen.setDate(morgen.getDate() + 1);
        
        const wt = ['So','Mo','Di','Mi','Do','Fr','Sa'];
        const label = `NACHT ${datum.getDate()}./${morgen.getDate()}.${datum.getMonth()+1}. (${wt[datum.getDay()]}/${wt[morgen.getDay()]})`;
        
        // Echte Wetterdaten
        const nachtWetter = forecastNaechte[i] || null;
        const windStr = nachtWetter ? nachtWetter.windrichtung : '?';
        
        // 50/50 Wind-Gewichte f√ºr Modell
        const gew = windGewichte(windStr) || { N: 0, S: 0, O: 0, W: 0 };
        
        // t = N√§chte seit letztem Besuch
        const tageSeit = Math.max(1, Math.round((datum - letzterBesuchDatum) / 86400000));
        
        // Sliding Window: f√ºr sp√§tere N√§chte sinkt der Faktor
        // (nach Nacht 1 ohne Besuch √§ndert sich die Sequenz)
        const pNext = i === 0 ? pNextBase : pNextBase * Math.max(0, 1 - i * 0.3);
        
        // Hazard-Vorhersage mit 50/50 Wind + Sliding Window
        let prob = hazardPredict(model, tageSeit, gew, pNext);
        prob = Math.max(0, Math.min(100, Math.round(prob)));
        
        const probClass = prob >= 35 ? 'prob-high' : prob >= 10 ? 'prob-medium' : 'prob-low';
        
        let hinweis = '';
        if (tageSeit <= 3) hinweis = `üî• ${tageSeit}N (Hot Zone)`;
        else if (tageSeit <= model.medianPause) hinweis = `${tageSeit}N (Normal)`;
        else if (tageSeit <= model.medianPause * 2) hinweis = `‚ö† ${tageSeit}N (√úberf√§llig)`;
        else hinweis = `üí§ ${tageSeit}N (Vergessen)`;
        
        // Sliding Window Hinweis
        if (pNext > 0.3 && i === 0) hinweis += ' üîÑ';
        
        forecast.push({ label, wind: windStr, prob, probClass, hinweis, wetter: nachtWetter, tageSeit });
    }
    return forecast;
}

// ============================================================
// AMPEL-STATUS
// ============================================================
function getAmpelStatus(kirrung, kirrungBesuche) {
    const heute = new Date();
    heute.setHours(0, 0, 0, 0);
    const kirrungen = kirrbestueckungen.filter(k => matchOrt(k.ort, kirrung));
    const letzte = kirrungen.sort((a, b) => b.datum_parsed - a.datum_parsed)[0];
    
    if (!letzte) {
        return { ampelClass: 'ampel-rot', icon: 'üî¥', text: '‚ö† Noch nie best√ºckt',
                 statusClass: 'warn', letzteKirr: 'Nie' };
    }
    
    const kirrDatum = new Date(letzte.datum_parsed);
    kirrDatum.setHours(0, 0, 0, 0);
    const tage = Math.round((heute - kirrDatum) / 86400000);
    const letzteKirr = tage === 0 ? 'Heute' : `vor ${tage} Tag${tage === 1 ? '' : 'en'}`;
    
    const besucheSeit = kirrungBesuche.filter(d => d.datum_parsed > letzte.datum_parsed);
    
    if (besucheSeit.length > 0) {
        return { ampelClass: 'ampel-rot', icon: 'üî¥',
                 text: `üêó ${besucheSeit.length} Besuch(e) seit Best√ºckung ‚Üí Nachkirren!`,
                 statusClass: 'warn', letzteKirr };
    }
    if (tage > 10) {
        return { ampelClass: 'ampel-rot', icon: 'üî¥',
                 text: `‚è∞ ${tage} Tage seit Best√ºckung ‚Üí Best√ºcken!`,
                 statusClass: 'warn', letzteKirr };
    }
    return { ampelClass: 'ampel-gruen', icon: 'üü¢',
             text: `‚úÖ Best√ºckt ${letzteKirr} ¬∑ Keine Besuche`,
             statusClass: 'ok', letzteKirr };
}

// ============================================================
// STATISTIKEN
// ============================================================
function getLetzterBesuch(nachtDaten) {
    if (nachtDaten.length === 0) return 'Keine Daten';
    const letzter = nachtDaten[nachtDaten.length - 1];
    
    // Heutiges Nacht-Datum (= heute 00:00) f√ºr korrekte Differenz
    const heuteNacht = new Date();
    heuteNacht.setHours(0, 0, 0, 0);
    
    const naechte = Math.round((heuteNacht - letzter) / 86400000);
    
    if (naechte === 0) return 'Heute Nacht (' + formatNachtLabel(letzter) + ')';
    if (naechte === 1) return 'Letzte Nacht (' + formatNachtLabel(letzter) + ')';
    return `vor ${naechte} N√§chten (${formatNachtLabel(letzter)})`;
}

function formatNachtLabel(nachtDatum) {
    const d1 = new Date(nachtDatum);
    const d2 = new Date(nachtDatum);
    d2.setDate(d2.getDate() + 1);
    return `${d1.getDate()}./${d2.getDate()}.${d1.getMonth()+1}.`;
}

function berechneWochentage(nachtDaten) {
    const tage = ['Mo','Di','Mi','Do','Fr','Sa','So'];
    const counts = [0,0,0,0,0,0,0];
    
    const unique = deduplicateNachtDaten(nachtDaten);
    unique.forEach(d => {
        const idx = (d.getDay() + 6) % 7;
        counts[idx]++;
    });
    
    const max = Math.max(...counts, 1);
    const total = counts.reduce((a, b) => a + b, 0);
    return tage.map((t, i) => {
        const c = counts[i];
        const w = c > 0 ? Math.max((c / max) * 100, 12) : 0;
        const countDisplay = c > 0
            ? `<div class="bar-fill" style="width:${w}%">${c}</div>`
            : `<div class="bar-fill" style="width:0%"></div><span style="color:var(--text-muted);font-family:var(--font-mono);font-size:0.75em;margin-left:4px">0</span>`;
        return `<div class="bar-row">
            <div class="bar-label">${t}</div>
            <div class="bar-track" style="display:flex;align-items:center;">${countDisplay}</div>
        </div>`;
    }).join('') + `<div style="font-size:0.75em;color:var(--text-muted);margin-top:6px;font-family:var(--font-mono);">Œ£ ${total} N√§chte</div>`;
}

function berechneUhrzeiten(besucheMitUhrzeit) {
    const displayStunden = [18,19,20,21,22,23,0,1,2,3,4,5];
    const counts = {};
    let total = 0;
    let failed = 0;
    
    besucheMitUhrzeit.forEach(d => {
        const h = d.stunde_von;  // Schon in parseEintrag extrahiert
        if (h !== null && h !== undefined && h >= 0 && h <= 23) {
            counts[h] = (counts[h] || 0) + 1;
            if (displayStunden.includes(h)) total++;
        } else {
            failed++;
        }
    });
    
    if (failed > 0) {
        console.warn(`‚ö†Ô∏è ${failed}/${besucheMitUhrzeit.length} Besuche ohne g√ºltige Stunde`);
    }
    
    const max = Math.max(...displayStunden.map(h => counts[h] || 0), 1);
    
    return displayStunden.map(h => {
        const c = counts[h] || 0;
        const w = c > 0 ? Math.max((c / max) * 100, 12) : 0;
        const label = h.toString().padStart(2, '0') + 'h';
        const countDisplay = c > 0
            ? `<div class="bar-fill" style="width:${w}%">${c}</div>`
            : `<div class="bar-fill" style="width:0%"></div><span style="color:var(--text-muted);font-family:var(--font-mono);font-size:0.75em;margin-left:4px">0</span>`;
        return `<div class="bar-row">
            <div class="bar-label">${label}</div>
            <div class="bar-track" style="display:flex;align-items:center;">${countDisplay}</div>
        </div>`;
    }).join('') + `<div style="font-size:0.75em;color:var(--text-muted);margin-top:6px;font-family:var(--font-mono);">Œ£ ${total} Besuche</div>`;
}

// ============================================================
// ORT MATCHING
// ============================================================
function matchOrt(ort, kirrung) {
    if (!ort) return false;
    const o = ort.toLowerCase();
    const k = kirrung.toLowerCase();
    // Mindestens 4 Zeichen matchen
    return o.includes(k.substring(0, 4)) || k.includes(o.substring(0, 4));
}

// ============================================================
// NLP PARSER
// ============================================================
function parseAndReview() {
    const text = document.getElementById('textInput').value.trim();
    if (!text) return alert('Bitte Beschreibung eingeben!');
    
    const lower = text.toLowerCase();
    
    // Datum
    let datum = new Date();
    if (lower.includes('gestern')) datum.setDate(datum.getDate() - 1);
    else if (lower.includes('vorgestern')) datum.setDate(datum.getDate() - 2);
    
    // Datum im Text? z.B. "12.2." oder "12.02."
    const datumMatch = text.match(/(\d{1,2})\.(\d{1,2})\./);
    if (datumMatch) {
        const tag = parseInt(datumMatch[1]);
        const monat = parseInt(datumMatch[2]) - 1;
        datum.setMonth(monat);
        datum.setDate(tag);
    }
    
    // Ort
    let ort = '';
    if (lower.includes('s√§g') || lower.includes('saeg')) ort = 'S√§gm√ºhle';
    else if (lower.includes('horl')) ort = 'Horlacher';
    else if (lower.includes('tier')) ort = 'Tiersbach';
    else if (lower.includes('gehr')) ort = 'Gehrlesklinge';
    else if (lower.includes('ost')) ort = 'Ostwind';
    else if (lower.includes('feucht')) ort = 'Feuchterswald';
    
    // Anzahl
    let anzahl = '';
    const zahlMatch = text.match(/(\d+)\s*(sau|schwein|st√ºck|√ºberl√§ufer|frisch|bach)/i);
    if (zahlMatch) anzahl = zahlMatch[1];
    
    // Uhrzeiten
    let von = '', bis = '';
    const vonMatch = text.match(/(?:von|ab|um)\s*(\d{1,2}):?(\d{2})/i);
    if (vonMatch) von = vonMatch[1].padStart(2, '0') + ':' + vonMatch[2];
    const bisMatch = text.match(/bis\s*(\d{1,2}):?(\d{2})/i);
    if (bisMatch) bis = bisMatch[1].padStart(2, '0') + ':' + bisMatch[2];
    
    showReviewModal({
        datum: datum.toISOString().split('T')[0],
        ort, anzahl, uhrzeit_von: von, uhrzeit_bis: bis, notizen: text
    });
}

function showReviewModal(data) {
    window._reviewData = data;
    const ortOptions = KIRRUNGEN.map(k =>
        `<option value="${k}" ${data.ort === k ? 'selected' : ''}>${k}</option>`
    ).join('');
    
    document.getElementById('reviewFields').innerHTML = `
        <div class="modal-field">
            <label>üìÖ Datum</label>
            <input type="date" id="rv_datum" value="${data.datum}">
        </div>
        <div class="modal-field">
            <label>üìç Ort</label>
            <select id="rv_ort">${ortOptions}</select>
        </div>
        <div class="modal-field">
            <label>üêó Anzahl</label>
            <input type="text" id="rv_anzahl" value="${data.anzahl}" placeholder="z.B. 3">
        </div>
        <div class="modal-field">
            <label>üïê Uhrzeit von</label>
            <input type="time" id="rv_von" value="${data.uhrzeit_von}">
        </div>
        <div class="modal-field">
            <label>üïê Uhrzeit bis</label>
            <input type="time" id="rv_bis" value="${data.uhrzeit_bis}">
        </div>
        <div class="modal-field">
            <label>üìù Notizen</label>
            <input type="text" id="rv_notizen" value="${data.notizen}">
        </div>`;
    
    document.getElementById('reviewModal').classList.add('show');
}

function closeModal() {
    document.getElementById('reviewModal').classList.remove('show');
}

async function saveFromReview() {
    const data = {
        action: 'besuch',
        datum: document.getElementById('rv_datum').value,
        ort: document.getElementById('rv_ort').value,
        anzahl: document.getElementById('rv_anzahl').value,
        uhrzeit_von: document.getElementById('rv_von').value,
        uhrzeit_bis: document.getElementById('rv_bis').value,
        notizen: document.getElementById('rv_notizen').value,
        wildart: 'Schwarzwild'
    };
    
    try {
        const params = new URLSearchParams(data);
        const resp = await fetch(`${API_URL}?${params}`);
        const result = await resp.json();
        
        if (result.success) {
            alert('‚úÖ Besuch gespeichert!');
            document.getElementById('textInput').value = '';
            closeModal();
            loadData();
        } else {
            alert('‚úï Fehler: ' + result.error);
        }
    } catch (err) {
        alert('‚úï Fehler: ' + err.message);
    }
}

async function submitKirrung() {
    const datum = document.getElementById('kirrDatum').value;
    if (!datum) return alert('Bitte Datum w√§hlen!');
    
    const checked = [...document.querySelectorAll('#kirrCheckboxes input:checked')];
    const kirrungen = checked.map(cb => cb.dataset.kirr);
    if (kirrungen.length === 0) return alert('Bitte mindestens eine Kirrung w√§hlen!');
    
    try {
        const url = `${API_URL}?action=kirrung&datum=${encodeURIComponent(datum)}&kirrungen=${encodeURIComponent(kirrungen.join(','))}`;
        const resp = await fetch(url);
        const result = await resp.json();
        
        if (result.success) {
            alert(`‚úÖ ${kirrungen.join(', ')} best√ºckt!`);
            checked.forEach(cb => cb.checked = false);
            loadData();
        } else {
            alert('‚úï Fehler: ' + result.error);
        }
    } catch (err) {
        alert('‚úï Fehler: ' + err.message);
    }
}

// ============================================================
// TAB SWITCHING
// ============================================================
function switchTab(tab) {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    if (tab === 'besuch') {
        document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
        document.getElementById('tabBesuch').classList.add('active');
    } else {
        document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
        document.getElementById('tabKirr').classList.add('active');
    }
}

// ============================================================
// HILFSFUNKTIONEN
// ============================================================
function formatDatum(d) {
    const tage = ['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'];
    const monate = ['Januar','Februar','M√§rz','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember'];
    return `${tage[d.getDay()]}, ${d.getDate()}. ${monate[d.getMonth()]} ${d.getFullYear()}`;
}
</script>
</body>
</html>
